{
  "name": {
    "am,ar,bg,bn,ca,cs,da,de,el,en,en_AU,en_GB,en_US,es,es_419,et,fa,fi,fil,fr,gu,he,hi,hr,hu,id,it,ja,kn,ko,lt,lv,ml,mr,ms,nl,no,pl,pt_BR,pt_PT,ro,ru,sk,sl,sr,sv,sw,ta,te,th,tr,uk,vi,zh_CN,zh_TW": "webhook"
  },
  "short": {
    "am,ar,bg,bn,ca,cs,da,de,el,en,en_AU,en_GB,en_US,es,es_419,et,fa,fi,fil,fr,gu,he,hi,hr,hu,id,it,ja,kn,ko,lt,lv,ml,mr,ms,nl,no,pl,pt_BR,pt_PT,ro,ru,sk,sl,sr,sv,sw,ta,te,th,tr,uk,vi,zh_CN,zh_TW": "js反调试工具"
  },
  "long": {
    "am,ar,bg,bn,ca,cs,da,de,el,en,en_AU,en_GB,en_US,es,es_419,et,fa,fi,fil,fr,gu,he,hi,hr,hu,id,it,ja,kn,ko,lt,lv,ml,mr,ms,nl,no,pl,pt_BR,pt_PT,ro,ru,sk,sl,sr,sv,sw,ta,te,th,tr,uk,vi,zh_CN,zh_TW": "主要解决问题..\n1、基于 console 的 devtool 检测\n有些网站会用 console 来检测是否打开了 F12（开发者工具），所以直接 hook console 对象 让所有输出失效，已达到过检测的目的。\n\n2、基于 pushState 的卡浏览器\n有些网站会不停的往 Chrome 缓存里塞东西（多见于 sojson 和一些仿 sojson 的网站），已干掉。\n\n3、基于 debugger 的卡浏览器 检测 devtool\n动态 debugger hook 了 Function.protype.constructor 替换所有的 debugger 字符（直接写在 js 里的 debugger 常量无法 hook（其实也行，但是我不知道怎么写在扩展里），只能自己右键，下一个条件断点过掉。）\n\n4、基于 regexp 的代码风格检测\n用正则检测代码是否格式化，直接干掉。\n\n5、基于 sojson 的反调试\n对于 sojsonV5，一键过所有反调试。\n\n6、基于 setInterval 的反调试\nhook setInterval，使其无法生效，但保留原有特征（无法被检测到是否被 hook 了，且当有函数检测时会提示。）\n\n7、基于 cookies 的加密定位\n大家都懂的。。\n\n8、基于 stringify 的 hook\n大家都懂的，实在找不到入口的时候，可以碰碰运气，一般在密码算法或特殊加密前，都会把明文对象通过 stringify 转为字符串。\n\n9、基于懒，所以会不断完善。。。"
  }
}